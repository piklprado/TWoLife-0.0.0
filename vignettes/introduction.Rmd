---
title: "TWoLife: Simulating Populations with Individual Variation in Heterogeneous Landscapes"
author: "Lucas Freitas"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{TWoLife: Simulating Populations with Individual Variation in Heterogeneous Landscapes}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5,
  fig.align = "center",
  cache = FALSE  # Disable caching for reproducibility
)
```

# Introduction

Understanding population dynamics in spatially heterogeneous
environments requires modeling both landscape structure and individual
variation. 
<!-- Afirmação sem referência para fundamentar -->
Existing approaches typically simplify one or both:
agent-based models often assume discrete habitat types, while analytical
models treat individuals as identical units. **TWoLife** integrates
these dimensions by simulating populations as collections of genetically
variable individuals inhabiting spatially complex landscapes.
<!-- Vários conceitos que não estão definidos precisamente (e.g., ambientes espacialmente heterogêneos, estrutura de paisagem e variação individual) -->

The package enables researchers to:

1.  Generate landscapes with **continuous environmental gradients** or
    **discrete habitat patches**
2.  Model **individual genetic variation** in optimal values, tolerance
    ranges, and behavioral strategies
<!-- parâmetros sem definição precisa: o que são optimal values etc?	 -->
3.  Implement **evolutionary mechanisms** including mutation,
    plasticity, and selection
<!-- Inconsistência conceitual. Neste caso porque estes apenas são mecanismos evolutivos? De maneira geral, avaliar se definições teóricas são usadas adequadamente	 -->
4.  Track **phenotype-environment interactions** that determine fitness
    and spatial distribution
5.  Analyze **emergent population dynamics** arising from
    individual-level processes

This vignette demonstrates TWoLife's capabilities through two
complementary analyses. We begin with a simplified example showing basic
workflow and discrete habitat structure, then proceed to the main
analysis showcasing individual genetic variation in continuous
environmental gradients—the core innovation of TWoLife.

# Package Setup

```{r load-package}
library(TWoLife)

# Simple seed management for testing reproducibility
set.seed(42)
```

# Package Overview

## Main Function

TWoLife provides a single main function with three parameter groups:
<!-- Sentença curta sem explicação suficiente para compreender os comandos que se seguem. Não tome os comandos e seus comentários no código como autoevidentes. -->
```{r eval=FALSE}
twolife_simulation(
  landscape_params,     # Spatial environment configuration
  individual_params,    # Population initialization
  genetic_params,       # Individual variation (optional)
  simulation_params,    # Simulation control
  master_seed           # Reproducibility
)
```

## Key Concepts

**Landscapes:** Spatial environments represented as matrices with
continuous or discrete values representing environmental conditions
(temperature, moisture, resource availability, etc.).

**Individuals:** Agents with genetic traits that determine fitness
through phenotype-environment matching. Each individual possesses:

-   `genotype_mean`: Genetically Optimal environmental value
-   `genotype_sd`: Niche width (tolerance range)
-   `mutation_rate`: Evolutionary change per reproduction
-   `plasticity`: Phenotypic adjustment capacity
-   `sampling_points`: Habitat selection behavior intensity

**Fitness:** Determined by Gaussian matching between individual
phenotype and local environmental value, rather than pre-assigned
habitat quality.

## Simulation Output

Simulations return lists containing:

-   **`summary`**: Final population statistics (population size, births,
    deaths, dispersals)
-   **`survivors`**: Individual-level data (ID, traits, locations,
    fitness)
-   **`events`**: Complete demographic history (all births, deaths,
    dispersals with timestamps)
-   **`parameters`**: All input parameters for reproducibility

## Basic Workflow

1.  Create or load landscape using `create_fractal_landscape()`
2.  Configure simulation parameters
3.  Run `twolife_simulation()`
4.  Extract results using helper functions or direct access
5.  Visualize using built-in plotting functions

# Basic Workflow Demonstration

Before exploring TWoLife's core capabilities (individual variation in
continuous landscapes), we demonstrate basic workflow using a simpler
scenario: discrete habitat/matrix landscapes. This example introduces
the main function, parameter structure, and output format using the
classic SLOSS (Single Large or Several Small) conservation question.

## Creating Landscapes

TWoLife provides `create_fractal_landscape()` for generating spatial
patterns. For binary habitat/matrix landscapes, set `habitat_proportion`
to the desired coverage:
<!-- Explicação que precede o comando omite a definição e/ou explicação de alguns parâmetros -->
```{r sloss-landscapes}
# Pristine: 100% habitat
set.seed(100)
pristine_landscape <- create_fractal_landscape(
  cells_per_row = 15,
  fractality = 0.5,
  habitat_proportion = 1.0
)

# Pre-configured SLOSS landscapes from package data
## Comentários com explicações que deveriam estar no corpo do texto
single_large_patch <- single_large      # 20% coverage, 1 patch
several_small_patches <- several_small  # 20% coverage, multiple patches
```

<!-- Chamada de comando sem nenhuma explicação do que está sendo feito, e dos parâmetros fundamentais usados -->
```{r visualize-sloss, fig.width=9, fig.height=3, echo=FALSE}
par(mfrow = c(1, 3), mar = c(4, 4, 3, 2))
plot_landscape(pristine_landscape, 
                            main = "Pristine\n(100% habitat)", 
                            colors = "habitat")
plot_landscape(single_large_patch, 
                            main = "Single Large\n(20% habitat)", 
                            colors = "habitat")
plot_landscape(several_small_patches, 
                            main = "Several Small\n(20% habitat)", 
                            colors = "habitat")
par(mfrow = c(1, 1), mar = c(5, 4, 4, 2))
```

## Running Simulations

The core function takes three parameter lists:
<!-- Indicação de objetos (no caso listas), sem sua caracterização ou definição. -->
```{r sloss-simulations}
sim_pristine <- twolife_simulation(
  landscape_params = list(habitat = pristine_landscape),
  individual_params = list(initial_population_size = 100),
  simulation_params = list(max_events = 300),
  master_seed = 42
)

sim_single_large <- twolife_simulation(
  landscape_params = list(habitat = single_large_patch),
  individual_params = list(initial_population_size = 100),
  simulation_params = list(max_events = 300),
  master_seed = 43
)

sim_several_small <- twolife_simulation(
  landscape_params = list(habitat = several_small_patches),
  individual_params = list(initial_population_size = 100),
  simulation_params = list(max_events = 300),
  master_seed = 44
)
```

## Extracting Results

Simulation objects contain summary statistics and detailed event
histories:
<!-- descrição incompleta do que o comando está sendo realizando.  -->
```{r sloss-results}
# Final population sizes
final_pops <- c(
  Pristine = sim_pristine$summary$final_population_size,
  Single_Large = sim_single_large$summary$final_population_size,
  Several_Small = sim_several_small$summary$final_population_size
)
final_pops

# Population trajectories
trajectory_pristine <- population_size(sim_pristine)
head(trajectory_pristine, 3)
```

```{r sloss-comparison, fig.width=8, fig.height=4, echo=FALSE}
par(mfrow = c(1, 2), mar = c(4, 4, 3, 2))

# Barplot
barplot(final_pops, 
        main = "Final Population Sizes",
        ylab = "Population Size (N)",
        col = c("darkgreen", "blue", "red"),
        las = 1)
text(x = seq(0.7, by = 1.2, length.out = 3), 
     y = final_pops + max(final_pops) * 0.05,
     labels = final_pops, cex = 1.1, font = 2)

# Trajectories
trajectory_single <- population_size(sim_single_large)
trajectory_several <- population_size(sim_several_small)

plot(trajectory_pristine$time, trajectory_pristine$population_size, 
     type = "l", col = "darkgreen", lwd = 2,
     main = "Population Dynamics", 
     xlab = "Time", ylab = "Population Size (N)",
     ylim = c(0, max(trajectory_pristine$population_size) * 1.05))
lines(trajectory_single$time, trajectory_single$population_size, 
      col = "blue", lwd = 2)
lines(trajectory_several$time, trajectory_several$population_size, 
      col = "red", lwd = 2)
legend("topright", legend = names(final_pops), 
       col = c("darkgreen", "blue", "red"), lwd = 2, bty = "n")

par(mfrow = c(1, 1), mar = c(5, 4, 4, 2))
```

## Summary

The pristine landscape supports `r final_pops["Pristine"]` individuals.
Reducing habitat to 20% yields `r final_pops["Single_Large"]`
individuals (single large) versus `r final_pops["Several_Small"]`
individuals (several small).
`r if(final_pops["Several_Small"] == 0) "The fragmented configuration experienced complete collapse, demonstrating that spatial arrangement can determine viability beyond simple area calculations." else paste0("Configuration accounts for a ", abs(final_pops["Single_Large"] - final_pops["Several_Small"]), "-individual difference despite identical habitat area.")`

This example demonstrates TWoLife's basic workflow: landscape creation,
parameter configuration, simulation execution, and result extraction. We
now turn to the package's primary innovation: modeling individual
genetic variation in continuous environmental gradients.

------------------------------------------------------------------------

# Main Analysis: Individual Variation in Heterogeneous Environments

## Background and Motivation

Real environments exhibit continuous variation—temperature gradients,
moisture clines, resource density surfaces. Real populations contain
genetically variable individuals with different optimal conditions and
tolerance ranges. TWoLife explicitly models both dimensions, enabling
investigation of questions inaccessible to traditional approaches:

-   **How much genetic variation is necessary** for persistence in
    heterogeneous landscapes?
-   **Is diversity in optimal values sufficient**, or must individuals
    also possess tolerance ranges (niche width)?
-   **What roles do evolution and behavior play** relative to standing
    genetic variation?
-   **How do mechanisms interact**—additively or synergistically?

We address these questions through progressive addition of genetic and
behavioral mechanisms, isolating each component's contribution to
population outcomes.

## Generating Continuous Landscapes

Setting `habitat_proportion = NULL` generates continuous environmental
values rather than binary habitat/matrix:

```{r continuous-landscape}
set.seed(200)
continuous_landscape <- create_fractal_landscape(
  cells_per_row = 15,
  fractality = 0.5,              # balanced spatial autocorrelation
  habitat_proportion = NULL,      # continuous values
  min_value = 0.0,
  max_value = 1.0
)
```

```{r visualize-continuous, fig.width=5, fig.height=4.5, echo=FALSE}
plot_landscape(continuous_landscape, 
                            main = "Continuous Environmental Landscape\n(fractality = 0.5)", 
                            colors = "terrain")
```

Values represent environmental conditions (temperature, moisture, etc.),
not inherent quality. Fitness depends on **phenotype-environment
matching**. This framework distinguishes TWoLife from models that
pre-assign habitat quality.

## Experimental Design: Progressive Mechanisms

We implement five scenarios differing only in genetic parameters:

| Scenario | Genetic Diversity | Niche Width | Evolution | Behavior |
|--------------|-----------------|--------------|--------------|--------------|
| 1\. Uniform specialists | No (all genotype=1.0) | No (sds=0) | No | No |
| 2\. Variable specialists | Yes (genotypes 0.3-0.7) | No (sds=0) | No | No |
| 3\. Generalists | Yes | **Yes (sds=0.15)** | No | No |
| 4\. Evolution | Yes | Yes | **Yes** (mutation, plasticity) | No |
| 5\. Habitat selection | Yes | Yes | Yes | **Yes** (sampling=100) |

All scenarios use 40 individuals, 250 events, and identical landscapes.
This design isolates each mechanism's contribution.

```{r pre-generate-genotypes}
# Pre-generate genotypes for Scenarios 2-5
set.seed(300)
initial_genotypes <- runif(40, 0.3, 0.7)
```

## Scenario 1: Uniform Perfect Specialists

**Configuration:** All individuals identical (genotype = 1.0), zero
tolerance.
<!-- descrição de condições da simulação e sua relação com parâmetros que não está clara. Porque parâmetros não estão definidos nem se explica a relação entre seus valores e a condição teórica que isso implica -->
**Hypothesis:** Population will collapse because the landscape lacks
environmental values of exactly 1.0.
<!-- Hipóteses ou afirmações apresentadas sem os elementos necessários para fundamentá-la -->
```{r scenario1}
sim_s1 <- twolife_simulation(
  landscape_params = list(habitat = continuous_landscape),
  individual_params = list(initial_population_size = 40),
  simulation_params = list(max_events = 250),
  master_seed = 45
)

(pop_s1 <- sim_s1$summary$final_population_size)
```

**Result:** N = `r pop_s1` (extinct). The landscape's environmental
values range from `r sprintf("%.2f", min(continuous_landscape))` to
`r sprintf("%.2f", max(continuous_landscape))` (mean =
`r sprintf("%.2f", mean(continuous_landscape))`), containing no exact
matches to the required value of 1.0.

**TWoLife enables:** Testing whether genetic uniformity is compatible
with environmental heterogeneity without analytical approximations.
<!-- Juízos de valor sem detalhamento e mais apropriados para uma discussão no paper. Dispensáveis numa vinheta. -->
## Scenario 2: Variable Specialists

**Configuration:** Different genotypes (0.3–0.7), but still zero
tolerance.

**Hypothesis:** Despite genetic diversity, population will collapse
because continuous landscapes rarely match specific genotype values
exactly.

```{r scenario2}
sim_s2 <- twolife_simulation(
  landscape_params = list(habitat = continuous_landscape),
  individual_params = list(initial_population_size = 40),
  genetic_params = list(
    genotype_means = initial_genotypes
  ),
  simulation_params = list(max_events = 250),
  master_seed = 46
)

(pop_s2 <- sim_s2$summary$final_population_size)
```

**Result:** N = `r pop_s2` (extinct). Even with 40 different genotypes
distributed across the environmental range, the probability of exact
matches remains negligible in continuous space.

**TWoLife enables:** Demonstrating that genotypic diversity ≠ survival
capacity without tolerance.

## Scenario 3: Generalists (Niche Width)

**Configuration:** Add `genotype_sds = 0.15`, creating tolerance ranges
of approximately ±0.3 around optimal values.

**Hypothesis:** Niche width will enable persistence by allowing
individuals to survive across a spectrum of conditions.

```{r scenario3}
sim_s3 <- twolife_simulation(
  landscape_params = list(habitat = continuous_landscape),
  individual_params = list(initial_population_size = 40),
  genetic_params = list(
    genotype_means = initial_genotypes,
    genotype_sds = rep(0.15, 40)
  ),
  simulation_params = list(max_events = 250),
  master_seed = 47
)

(pop_s3 <- sim_s3$summary$final_population_size)
```

**Result:** N = `r pop_s3` (`r sprintf("%.1f%%", pop_s3/40*100)`
survival). This marks the **critical transition** from extinction to
viability.

```{r scenario3-analysis}
# Examine survivor traits
if (pop_s3 > 0) {
  survivor_summary <- c(
    Mean_genotype = mean(sim_s3$survivors$genotype),
    SD_genotype = sd(sim_s3$survivors$genotype),
    Range = paste0("[", sprintf("%.2f", min(sim_s3$survivors$genotype)), 
                   ", ", sprintf("%.2f", max(sim_s3$survivors$genotype)), "]")
  )
  survivor_summary
}
```

An individual with genotype 0.5 and niche width 0.15 (±2σ ≈ ±0.3) can
survive in environmental conditions from \~0.2 to \~0.8, transforming
the landscape from unusable to accessible.

**TWoLife enables:** Quantifying exactly how tolerance ranges determine
effective habitat availability, with individual-level tracking of trait
distributions.

## Scenario 4: Evolution (Mutation + Plasticity)

**Configuration:** Add `mutation_rates = 0.05` (5% genetic change per
reproduction) and `plasticities = 0.02` (2% phenotypic adjustment).

**Hypothesis:** Evolutionary mechanisms will enhance persistence through
dual-timescale adaptation.

```{r scenario4}
sim_s4 <- twolife_simulation(
  landscape_params = list(habitat = continuous_landscape),
  individual_params = list(initial_population_size = 40),
  genetic_params = list(
    genotype_means = initial_genotypes,
    genotype_sds = rep(0.15, 40),
    mutation_rates = rep(0.05, 40),
    plasticities = rep(0.02, 40)
  ),
  simulation_params = list(max_events = 250),
  master_seed = 48
)

(pop_s4 <- sim_s4$summary$final_population_size)
(delta_evolution <- pop_s4 - pop_s3)
```

**Result:** N = `r pop_s4` (change: `r sprintf("%+d", delta_evolution)`
from Scenario 3). Evolution
`r if(delta_evolution > 0) paste0("enhanced survival by ", delta_evolution, " individuals") else if(delta_evolution == 0) "maintained equivalent survival" else paste0("resulted in ", abs(delta_evolution), " fewer survivors, likely due to demographic stochasticity")`.

**TWoLife enables:** Separating evolutionary effects from standing
genetic variation by progressively adding mechanisms with identical
landscapes and initial conditions.

## Scenario 5: Habitat Selection (Behavioral Optimization)

**Configuration:** Add `sampling_points = 100`, enabling individuals to
evaluate 100 locations per dispersal and choose the best
phenotype-environment match.
<!-- Descrição de uso de parâmetro sem explicação suficiente do que esta parâmetro controla, e como (no caso a preferência de habitat) -->
**Hypothesis:** Behavioral habitat selection will optimize spatial
distribution and amplify genetic potential.

```{r scenario5}
sim_s5 <- twolife_simulation(
  landscape_params = list(habitat = continuous_landscape),
  individual_params = list(initial_population_size = 40),
  genetic_params = list(
    genotype_means = initial_genotypes,
    genotype_sds = rep(0.15, 40),
    mutation_rates = rep(0.05, 40),
    plasticities = rep(0.02, 40),
    sampling_points = rep(100, 40)
  ),
  simulation_params = list(max_events = 250),
  master_seed = 49
)

(pop_s5 <- sim_s5$summary$final_population_size)
(delta_behavior <- pop_s5 - pop_s4)
(cumulative_gain <- pop_s5 - pop_s2)
```

**Result:** N = `r pop_s5` (change: `r sprintf("%+d", delta_behavior)`
from Scenario 4). Cumulative improvement from extinct baseline:
**`r cumulative_gain` individuals**.

**TWoLife enables:** Implementing active habitat selection through
mechanistically explicit sampling and choice processes, demonstrating
behavioral amplification of genetic traits.

## Comparative Analysis
<!-- Apresnetação de gráfico ou tabela sem enhum texto explicativo deste elemento de resultado -->
```{r comparative-summary}
# Summary table
results_summary <- data.frame(
  Scenario = c("S1: Uniform", "S2: Diversity", "S3: Tolerance", 
               "S4: Evolution", "S5: Behavior"),
  Final_N = c(pop_s1, pop_s2, pop_s3, pop_s4, pop_s5),
  Change = c("—", 
             sprintf("%+d", pop_s2 - pop_s1),
             sprintf("%+d", pop_s3 - pop_s2),
             sprintf("%+d", pop_s4 - pop_s3),
             sprintf("%+d", pop_s5 - pop_s4))
)
results_summary
```

The S2 → S3 transition (adding tolerance) accounts for
`r pop_s3 - pop_s2` individuals—the largest contribution. Subsequent
mechanisms provide incremental effects of `r pop_s4 - pop_s3`
(evolution) and `r pop_s5 - pop_s4` (behavior).

```{r comparative-visualization, fig.width=9, fig.height=4.5, echo=FALSE}
par(mfrow = c(1, 2), mar = c(5, 4, 3, 2))

# Population dynamics
traj_s3 <- population_size(sim_s3)
traj_s4 <- population_size(sim_s4)
traj_s5 <- population_size(sim_s5)

max_pop <- max(c(traj_s3$population_size, traj_s4$population_size, traj_s5$population_size))
plot(traj_s3$time, traj_s3$population_size, type = "l", col = "blue", lwd = 2,
     main = "Population Trajectories", xlab = "Time", ylab = "Population Size (N)",
     ylim = c(0, max_pop * 1.05))
lines(traj_s4$time, traj_s4$population_size, col = "darkgreen", lwd = 2)
lines(traj_s5$time, traj_s5$population_size, col = "purple", lwd = 2)
abline(h = 40, lty = 2, col = "gray50")
legend("topright", legend = c("S3: Tolerance", "S4: Evolution", "S5: Behavior"),
       col = c("blue", "darkgreen", "purple"), lwd = 2, bty = "n", cex = 0.85)

# Final comparison
barplot(c(pop_s1, pop_s2, pop_s3, pop_s4, pop_s5),
        names.arg = c("S1", "S2", "S3", "S4", "S5"),
        main = "Final Population Sizes",
        ylab = "Population Size (N)",
        col = c("red", "red", "yellow", "lightgreen", "darkgreen"))
text(x = seq(0.7, by = 1.2, length.out = 5), 
     y = c(pop_s1, pop_s2, pop_s3, pop_s4, pop_s5) + max(c(1, pop_s3, pop_s4, pop_s5)) * 0.05,
     labels = c(pop_s1, pop_s2, pop_s3, pop_s4, pop_s5),
     cex = 1.1, font = 2)

par(mfrow = c(1, 1), mar = c(5, 4, 4, 2))
```

## Verifying Phenotype-Environment Matching

The `check_habitat_match()` function provides a diagnostic tool to
verify that survivors occupy environmentally suitable locations. The
function displays the landscape with survivor positions colored by
phenotype, alongside a scatterplot of phenotype versus occupied
environmental values.
<!-- Descrição incorreta ou imprecisa. No caso um scatterplot de phebotypo versus valores ambientais ocupados deveria ter esta segunda variável no eixo do X, o que não acontece -->
```{r validation-s3, fig.width=8, fig.height=4}
# Scenario 3: Tolerance
if (pop_s3 > 0) {
  check_habitat_match(sim_s3, 
                           color_by = "phenotype", 
                           landscape_colors = "terrain",
                           point_size = 1.5,
                           show_legend = FALSE)
}
```

```{r validation-s4, fig.width=8, fig.height=4}
# Scenario 4: Evolution
if (pop_s4 > 0) {
  check_habitat_match(sim_s4, 
                           color_by = "phenotype", 
                           landscape_colors = "terrain",
                           point_size = 1.5,
                           show_legend = FALSE)
}
```

```{r validation-s5, fig.width=8, fig.height=4}
# Scenario 5: Habitat Selection
if (pop_s5 > 0) {
  check_habitat_match(sim_s5, 
                           color_by = "phenotype", 
                           landscape_colors = "terrain",
                           point_size = 1.5,
                           show_legend = FALSE)
}
```

```{r compute-correlations, echo=FALSE}
# Compute correlations across scenarios
if (pop_s3 > 0 && "phenotype" %in% names(sim_s3$survivors) &&
    "habitat_quality" %in% names(sim_s3$survivors)) {
  cor_s3 <- cor(sim_s3$survivors$phenotype, 
                sim_s3$survivors$habitat_quality, 
                use = "complete.obs")
} else {
  cor_s3 <- NA
}

if (pop_s4 > 0 && "phenotype" %in% names(sim_s4$survivors) &&
    "habitat_quality" %in% names(sim_s4$survivors)) {
  cor_s4 <- cor(sim_s4$survivors$phenotype, 
                sim_s4$survivors$habitat_quality, 
                use = "complete.obs")
} else {
  cor_s4 <- NA
}

if (pop_s5 > 0 && "phenotype" %in% names(sim_s5$survivors) &&
    "habitat_quality" %in% names(sim_s5$survivors)) {
  cor_s5 <- cor(sim_s5$survivors$phenotype, 
                sim_s5$survivors$habitat_quality, 
                use = "complete.obs")
} else {
  cor_s5 <- NA
}
```

The visualizations confirm phenotype-environment matching across all
viable scenarios. Individuals with low phenotypes consistently occupy
low-value regions, while high-phenotype individuals occupy high-value
regions. This spatial sorting reflects the fundamental
phenotype-environment matching mechanism. Quantitatively, survivor
phenotypes correlate strongly with occupied environmental values: S3 (r
= `r if(!is.na(cor_s3)) sprintf("%.2f", cor_s3) else "NA"`), S4 (r =
`r if(!is.na(cor_s4)) sprintf("%.2f", cor_s4) else "NA"`), S5 (r =
`r if(!is.na(cor_s5)) sprintf("%.2f", cor_s5) else "NA"`), verifying
that TWoLife correctly implements the fitness model.

# Understanding Simulation Output

## Object Structure

Simulation objects are lists with four main components:
<!-- Repetição de informação já fornecida em outra seção -->
```{r output-structure}
# Examine structure
names(sim_s5)

# Summary statistics
sim_s5$summary
```

## Accessing Components
<!-- Seções inteiras apenas com códigos, sem explicações do que é feito. Um caso extremos de blocos de código sem explicação ou com explicação insuficiente -->
```{r accessing-components}
# Individual-level data
if (isTRUE(!is.null(sim_s5$survivors) && is.data.frame(sim_s5$survivors) && nrow(sim_s5$survivors) > 0)) {
  head(sim_s5$survivors, 3)
}

# Event history
if (isTRUE(!is.null(sim_s5$events) && is.data.frame(sim_s5$events) && nrow(sim_s5$events) > 0)) {
  head(sim_s5$events, 3)
}

# Parameters (for reproducibility)
if (!is.null(sim_s5$parameters)) {
  str(sim_s5$parameters, max.level = 1)
}
```

## Helper Functions

TWoLife provides functions for common analyses:

```{r helper-functions}
# Population trajectory
trajectory <- population_size(sim_s5)
if (isTRUE(!is.null(trajectory) && is.data.frame(trajectory) && nrow(trajectory) > 0)) {
  head(trajectory, 3)
}

# Spatial validation (shown in previous section)
# check_habitat_match(sim_s5)
```

## Custom Analysis Example

Users can directly analyze simulation data:

```{r custom-analysis, fig.width=7, fig.height=4}
# Analyze trait distribution over time
if (isTRUE(!is.null(sim_s5$events) && is.data.frame(sim_s5$events) && nrow(sim_s5$events) > 0)) {
  births <- subset(sim_s5$events, event_type == "birth")
  
  if (isTRUE(nrow(births) > 10 && "offspring_genotype" %in% names(births))) {
    plot(births$time, births$offspring_genotype, 
         pch = 16, cex = 0.6, col = rgb(0, 0, 1, 0.3),
         xlab = "Time", ylab = "Offspring Genotype",
         main = "Genotype Evolution Over Time")
    
    # Add trend line
    if (nrow(births) > 2) {
      trend <- loess(offspring_genotype ~ time, data = births, span = 0.3)
      lines(births$time, predict(trend), col = "red", lwd = 2)
    }
  }
} else {
  # If no events data, show alternative analysis
  if (isTRUE(pop_s5 > 0 && !is.null(sim_s5$survivors) && is.data.frame(sim_s5$survivors) && nrow(sim_s5$survivors) > 0)) {
    if (all(c("genotype", "phenotype") %in% names(sim_s5$survivors))) {
      plot(sim_s5$survivors$genotype, sim_s5$survivors$phenotype,
           pch = 16, col = rgb(0, 0, 1, 0.5),
           xlab = "Genotype", ylab = "Phenotype",
           main = "Genotype-Phenotype Relationship in Survivors")
      abline(0, 1, col = "red", lty = 2)
    }
  }
}
```

# Parameter Reference

## Core Parameters

### landscape_params

-   **habitat**: Landscape matrix (required)

### individual_params

-   **initial_population_size**: Starting population (required)

### genetic_params (all optional)

-   **genotype_means**: Optimal environmental values (default: 1.0 for
    all)
-   **genotype_sds**: Niche widths/tolerance (default: 0.0 for all)
-   **mutation_rates**: Genetic change per reproduction (default: 0.0
    for all)
-   **plasticities**: Phenotypic adjustment rate (default: 0.0 for all)
-   **sampling_points**: Locations evaluated per dispersal (default: 1
    for all)

### simulation_params

-   **max_events**: Stopping criterion (required)

### master_seed

-   **master_seed**: Random seed for reproducibility (recommended)

## Example Parameter Configurations

```{r parameter-examples, eval=FALSE}
# Minimal (uniform population)
twolife_simulation(
  landscape_params = list(habitat = my_landscape),
  individual_params = list(initial_population_size = 50),
  simulation_params = list(max_events = 300),
  master_seed = 42
)

# With genetic variation
twolife_simulation(
  landscape_params = list(habitat = my_landscape),
  individual_params = list(initial_population_size = 50),
  genetic_params = list(
    genotype_means = runif(50, 0.3, 0.7),
    genotype_sds = rep(0.15, 50)
  ),
  simulation_params = list(max_events = 300),
  master_seed = 42
)

# Full configuration
twolife_simulation(
  landscape_params = list(habitat = my_landscape),
  individual_params = list(initial_population_size = 50),
  genetic_params = list(
    genotype_means = runif(50, 0.3, 0.7),
    genotype_sds = rep(0.15, 50),
    mutation_rates = rep(0.05, 50),
    plasticities = rep(0.02, 50),
    sampling_points = rep(100, 50)
  ),
  simulation_params = list(max_events = 300),
  master_seed = 42
)
```

# Computational Considerations

## Performance Characteristics

```{r timing, echo=TRUE}
# Example timing for moderate complexity
system.time(
  test_sim <- twolife_simulation(
    landscape_params = list(habitat = continuous_landscape),
    individual_params = list(initial_population_size = 40),
    genetic_params = list(
      genotype_means = initial_genotypes,
      genotype_sds = rep(0.15, 40),
      mutation_rates = rep(0.05, 40),
      plasticities = rep(0.02, 40)
    ),
    simulation_params = list(max_events = 250),
    master_seed = 50
  )
)
```

Typical simulations (40 individuals, 250 events, 15×15 landscape)
complete in seconds on standard hardware. Scaling considerations:

-   **Population size:** Linear to slightly superlinear (due to
    density-dependent interactions)
-   **Landscape size:** Linear (larger landscapes don't increase
    per-event computation)
-   **Event count:** Linear (each event is independent)
-   **Habitat selection:** Linear in `sampling_points` (each location
    evaluated independently)

## Memory Usage

```{r memory}
# Simulation object size
format(object.size(sim_s5), units = "Kb")

# Components
c(
  Events = format(object.size(sim_s5$events), units = "Kb"),
  Survivors = format(object.size(sim_s5$survivors), units = "Kb"),
  Summary = format(object.size(sim_s5$summary), units = "Kb")
)
```

Memory scales with event count and population size. For large-scale
parameter sweeps, consider storing only essential outputs.

## Reproducibility

TWoLife ensures complete reproducibility through explicit seed
management:

```{r reproducibility-demo}
# Same parameters, same seed -> identical results
sim_test1 <- twolife_simulation(
  landscape_params = list(habitat = continuous_landscape),
  individual_params = list(initial_population_size = 10),
  simulation_params = list(max_events = 50),
  master_seed = 999
)

sim_test2 <- twolife_simulation(
  landscape_params = list(habitat = continuous_landscape),
  individual_params = list(initial_population_size = 10),
  simulation_params = list(max_events = 50),
  master_seed = 999
)

identical(sim_test1$summary$final_population_size, 
          sim_test2$summary$final_population_size)
```

This applies across R sessions, platforms, and package versions,
supporting reproducible research workflows.

## Running Multiple Simulations

For parameter exploration or replication studies:

```{r multiple-sims, eval=FALSE}
# Example: Test effect of niche width
niche_widths <- seq(0.05, 0.25, by = 0.05)
results <- vector("list", length(niche_widths))

for (i in seq_along(niche_widths)) {
  results[[i]] <- twolife_simulation(
    landscape_params = list(habitat = continuous_landscape),
    individual_params = list(initial_population_size = 40),
    genetic_params = list(
      genotype_means = runif(40, 0.3, 0.7),
      genotype_sds = rep(niche_widths[i], 40)
    ),
    simulation_params = list(max_events = 250),
    master_seed = 1000 + i
  )
}

# Extract results
final_pops <- sapply(results, function(x) x$summary$final_population_size)
plot(niche_widths, final_pops, type = "b",
     xlab = "Niche Width", ylab = "Final Population Size")
```

# Discussion

## What TWoLife Enables

**Continuous environmental representation:** Unlike most
individual-based models that discretize space into habitat types,
TWoLife handles continuous gradients representing realistic
environmental variation.

**Individual-level genetic architecture:** Each individual possesses
unique genotype means, niche widths, mutation rates, plasticity
coefficients, and behavioral parameters—all heritable, mutable, and
mechanistically implemented.

**Phenotype-environment matching framework:** Fitness emerges from
trait-environment interactions rather than pre-assigned habitat quality,
enabling investigation of matching processes, local adaptation, and
niche evolution.

**Flexible mechanism integration:** Users control which mechanisms
operate (genetics, plasticity, evolution, behavior) through parameter
specification, enabling systematic hypothesis testing about mechanism
necessity and sufficiency.

**Complete transparency:** All individual traits, locations, and fitness
consequences are tracked throughout simulations, supporting validation
and detailed analysis of emergent patterns.


# Conclusion

**TWoLife** provides a flexible framework for simulating populations as
collections of genetically variable individuals inhabiting spatially
heterogeneous landscapes. Through systematic experimentation, this
vignette demonstrated:

**Core capabilities:** - Generation of discrete habitat patches and
continuous environmental gradients - Individual-level tracking of
genetic traits, phenotypes, and fitness - Flexible integration of
evolutionary and behavioral mechanisms - Complete reproducibility and
computational efficiency

**Key findings:** - Niche width (tolerance ranges) is necessary and
sufficient for persistence in heterogeneous environments - Genetic
diversity without physiological flexibility is insufficient - Evolution
and behavior enhance but cannot replace fundamental tolerance -
Mechanisms interact synergistically rather than additively

**Scientific value:** - Addresses questions inaccessible to models
lacking individual variation or continuous spatial heterogeneity -
Enables hypothesis testing about mechanism necessity and sufficiency -
Provides quantitative predictions about population outcomes from
individual-level processes - Supports reproducible, mechanistically
explicit research workflows

By integrating spatial heterogeneity and individual variation within a
unified simulation framework, TWoLife advances our capacity to
understand population dynamics, evolutionary processes, and conservation
strategies in realistic ecological contexts.
